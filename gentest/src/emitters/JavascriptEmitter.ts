/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */

import Emitter from './Emitter.ts';
import type {ValueWithUnit, GridTrack, GridTrackValue} from '../Types.ts';

function toValueJavascript(value: ValueWithUnit): string {
  switch (value.type) {
    case 'points':
      return String(value.value);
    case 'percent':
      return JSON.stringify(value.value + '%');
    case 'auto':
      return '"auto"';
    case 'max-content':
      return '"max-content"';
    case 'fit-content':
      return '"fit-content"';
    case 'stretch':
      return '"stretch"';
    case 'undefined':
      return 'undefined';
  }
}

function formatGridTrackValueJS(track: GridTrackValue): string {
  switch (track.type) {
    case 'auto':
      return '{type: GridTrackType.Auto}';
    case 'points':
      return `{type: GridTrackType.Points, value: ${track.value}}`;
    case 'percent':
      return `{type: GridTrackType.Percent, value: ${track.value}}`;
    case 'fr':
      return `{type: GridTrackType.Fr, value: ${track.value}}`;
    default:
      return '{type: GridTrackType.Auto}';
  }
}

export class JavascriptEmitter extends Emitter {
  private static enumMap: Record<string, string> = {
    YGAlignAuto: 'Align.Auto',
    YGAlignCenter: 'Align.Center',
    YGAlignFlexEnd: 'Align.FlexEnd',
    YGAlignFlexStart: 'Align.FlexStart',
    YGAlignStretch: 'Align.Stretch',
    YGAlignSpaceBetween: 'Align.SpaceBetween',
    YGAlignSpaceAround: 'Align.SpaceAround',
    YGAlignSpaceEvenly: 'Align.SpaceEvenly',
    YGAlignBaseline: 'Align.Baseline',
    YGAlignStart: 'Align.Start',
    YGAlignEnd: 'Align.End',
    YGDirectionInherit: 'Direction.Inherit',
    YGDirectionLTR: 'Direction.LTR',
    YGDirectionRTL: 'Direction.RTL',
    YGEdgeBottom: 'Edge.Bottom',
    YGEdgeEnd: 'Edge.End',
    YGEdgeLeft: 'Edge.Left',
    YGEdgeRight: 'Edge.Right',
    YGEdgeStart: 'Edge.Start',
    YGEdgeTop: 'Edge.Top',
    YGEdgeAll: 'Edge.All',
    YGEdgeVertical: 'Edge.Vertical',
    YGEdgeHorizontal: 'Edge.Horizontal',
    YGGutterAll: 'Gutter.All',
    YGGutterColumn: 'Gutter.Column',
    YGGutterRow: 'Gutter.Row',
    YGFlexDirectionColumn: 'FlexDirection.Column',
    YGFlexDirectionColumnReverse: 'FlexDirection.ColumnReverse',
    YGFlexDirectionRow: 'FlexDirection.Row',
    YGFlexDirectionRowReverse: 'FlexDirection.RowReverse',
    YGJustifyCenter: 'Justify.Center',
    YGJustifyFlexEnd: 'Justify.FlexEnd',
    YGJustifyFlexStart: 'Justify.FlexStart',
    YGJustifySpaceAround: 'Justify.SpaceAround',
    YGJustifySpaceBetween: 'Justify.SpaceBetween',
    YGJustifySpaceEvenly: 'Justify.SpaceEvenly',
    YGJustifyStretch: 'Justify.Stretch',
    YGJustifyStart: 'Justify.Start',
    YGJustifyEnd: 'Justify.End',
    YGJustifyAuto: 'Justify.Auto',
    YGOverflowHidden: 'Overflow.Hidden',
    YGOverflowVisible: 'Overflow.Visible',
    YGOverflowScroll: 'Overflow.Scroll',
    YGPositionTypeAbsolute: 'PositionType.Absolute',
    YGPositionTypeRelative: 'PositionType.Relative',
    YGPositionTypeStatic: 'PositionType.Static',
    YGWrapNoWrap: 'Wrap.NoWrap',
    YGWrapWrap: 'Wrap.Wrap',
    YGWrapWrapReverse: 'Wrap.WrapReverse',
    YGDisplayFlex: 'Display.Flex',
    YGDisplayNone: 'Display.None',
    YGDisplayContents: 'Display.Contents',
    YGDisplayGrid: 'Display.Grid',
    YGBoxSizingBorderBox: 'BoxSizing.BorderBox',
    YGBoxSizingContentBox: 'BoxSizing.ContentBox',
  };

  private tr(value: string): string {
    return JavascriptEmitter.enumMap[value] ?? value;
  }

  constructor() {
    super('  ');
  }

  emitCommentHeader(fixtureName: string): void {
    this.push([
      '/**',
      ' * Copyright (c) Meta Platforms, Inc. and affiliates.',
      ' *',
      ' * This source code is licensed under the MIT license found in the',
      ' * LICENSE file in the root directory of this source tree.',
      ' *',
      ' * MAGIC_PLACEHOLDER',
      ' * generated by gentest/src/GentestDriver.ts from gentest/fixtures/' +
        fixtureName +
        '.html',
      ' */',
      '',
    ]);
  }

  emitPrologue(_fixtureName: string): void {
    this.push("import { instrinsicSizeMeasureFunc } from '../tools/utils.ts'");
    this.push("import Yoga from 'yoga-layout';");
    this.push('import {');
    this.pushIndent();
    this.push('Align,');
    this.push('BoxSizing,');
    this.push('Direction,');
    this.push('Display,');
    this.push('Edge,');
    this.push('Errata,');
    this.push('ExperimentalFeature,');
    this.push('FlexDirection,');
    this.push('GridTrackType,');
    this.push('Gutter,');
    this.push('Justify,');
    this.push('MeasureMode,');
    this.push('Overflow,');
    this.push('PositionType,');
    this.push('Unit,');
    this.push('Wrap,');
    this.popIndent();
    this.push("} from 'yoga-layout';");
    this.push('');
  }

  emitTestPrologue(
    name: string,
    experiments: string[],
    disabled: boolean,
  ): void {
    const testFn = disabled ? 'test.skip' : 'test';
    this.push(`${testFn}('${name}', () => {`);
    this.pushIndent();
    this.push('const config = Yoga.Config.create();');
    this.push('let root;');
    this.push('');

    if (experiments.length > 0) {
      for (const experiment of experiments) {
        this.push(
          `config.setExperimentalFeatureEnabled(ExperimentalFeature.${experiment}, true);`,
        );
      }
      this.push('');
    }

    this.push('try {');
    this.pushIndent();
  }

  emitTestTreePrologue(nodeName: string): void {
    if (nodeName === 'root') {
      this.push('root = Yoga.Node.create(config);');
    } else {
      this.push(`const ${nodeName} = Yoga.Node.create(config);`);
    }
  }

  emitTestEpilogue(_experiments: string[]): void {
    this.popIndent();
    this.push('} finally {');
    this.pushIndent();

    this.push("if (typeof root !== 'undefined') {");
    this.pushIndent();
    this.push('root.freeRecursive();');
    this.popIndent();
    this.push('}');
    this.push('');
    this.push('config.free();');

    this.popIndent();
    this.push('}');

    this.popIndent();
    this.push('});');
  }

  emitEpilogue(): void {
    this.push('');
  }

  assertEQ(v0: number, v1: string): void {
    this.push(`expect(${v1}).toBe(${v0});`);
  }

  layoutGetLeft(node: string): string {
    return node + '.getComputedLeft()';
  }

  layoutGetTop(node: string): string {
    return node + '.getComputedTop()';
  }

  layoutGetWidth(node: string): string {
    return node + '.getComputedWidth()';
  }

  layoutGetHeight(node: string): string {
    return node + '.getComputedHeight()';
  }

  insertChild(parent: string, child: string, index: number): void {
    this.push(parent + '.insertChild(' + child + ', ' + index + ');');
  }

  calculateLayout(
    node: string,
    direction: string,
    _experiments: string[],
  ): void {
    this.push(
      node +
        '.calculateLayout(undefined, undefined, ' +
        this.tr(direction) +
        ');',
    );
  }

  setMeasureFunc(node: string, text: string, flexDirection: string): void {
    this.push(
      `${node}.setMeasureFunc(instrinsicSizeMeasureFunc.bind({text: "${text}", flexDirection: ${this.tr(
        flexDirection,
      )}}));`,
    );
  }

  setDirection(node: string, value: string): void {
    this.push(node + '.setDirection(' + this.tr(value) + ');');
  }

  setFlexDirection(node: string, value: string): void {
    this.push(node + '.setFlexDirection(' + this.tr(value) + ');');
  }

  setJustifyContent(node: string, value: string): void {
    this.push(node + '.setJustifyContent(' + this.tr(value) + ');');
  }

  setJustifyItems(node: string, value: string): void {
    this.push(node + '.setJustifyItems(' + this.tr(value) + ');');
  }

  setJustifySelf(node: string, value: string): void {
    this.push(node + '.setJustifySelf(' + this.tr(value) + ');');
  }

  setAlignContent(node: string, value: string): void {
    this.push(node + '.setAlignContent(' + this.tr(value) + ');');
  }

  setAlignItems(node: string, value: string): void {
    this.push(node + '.setAlignItems(' + this.tr(value) + ');');
  }

  setAlignSelf(node: string, value: string): void {
    this.push(node + '.setAlignSelf(' + this.tr(value) + ');');
  }

  setPositionType(node: string, value: string): void {
    this.push(node + '.setPositionType(' + this.tr(value) + ');');
  }

  setFlexWrap(node: string, value: string): void {
    this.push(node + '.setFlexWrap(' + this.tr(value) + ');');
  }

  setOverflow(node: string, value: string): void {
    this.push(node + '.setOverflow(' + this.tr(value) + ');');
  }

  setDisplay(node: string, value: string): void {
    this.push(node + '.setDisplay(' + this.tr(value) + ');');
  }

  setBoxSizing(node: string, value: string): void {
    this.push(node + '.setBoxSizing(' + this.tr(value) + ');');
  }

  setFlexGrow(node: string, value: string): void {
    this.push(node + '.setFlexGrow(' + value + ');');
  }

  setFlexShrink(node: string, value: string): void {
    this.push(node + '.setFlexShrink(' + value + ');');
  }

  setFlexBasis(node: string, value: ValueWithUnit): void {
    this.push(node + '.setFlexBasis(' + toValueJavascript(value) + ');');
  }

  setWidth(node: string, value: ValueWithUnit): void {
    this.push(node + '.setWidth(' + toValueJavascript(value) + ');');
  }

  setHeight(node: string, value: ValueWithUnit): void {
    this.push(node + '.setHeight(' + toValueJavascript(value) + ');');
  }

  setMinWidth(node: string, value: ValueWithUnit): void {
    this.push(node + '.setMinWidth(' + toValueJavascript(value) + ');');
  }

  setMinHeight(node: string, value: ValueWithUnit): void {
    this.push(node + '.setMinHeight(' + toValueJavascript(value) + ');');
  }

  setMaxWidth(node: string, value: ValueWithUnit): void {
    this.push(node + '.setMaxWidth(' + toValueJavascript(value) + ');');
  }

  setMaxHeight(node: string, value: ValueWithUnit): void {
    this.push(node + '.setMaxHeight(' + toValueJavascript(value) + ');');
  }

  setMargin(node: string, edge: string, value: ValueWithUnit): void {
    this.push(
      node +
        '.setMargin(' +
        this.tr(edge) +
        ', ' +
        toValueJavascript(value) +
        ');',
    );
  }

  setPadding(node: string, edge: string, value: ValueWithUnit): void {
    this.push(
      node +
        '.setPadding(' +
        this.tr(edge) +
        ', ' +
        toValueJavascript(value) +
        ');',
    );
  }

  setPosition(node: string, edge: string, value: ValueWithUnit): void {
    const v = toValueJavascript(value);
    if (v === '"auto"') {
      this.push(node + '.setPositionAuto(' + this.tr(edge) + ');');
    } else {
      this.push(node + '.setPosition(' + this.tr(edge) + ', ' + v + ');');
    }
  }

  setBorder(node: string, edge: string, value: ValueWithUnit): void {
    this.push(
      node +
        '.setBorder(' +
        this.tr(edge) +
        ', ' +
        toValueJavascript(value) +
        ');',
    );
  }

  setGap(node: string, gutter: string, value: ValueWithUnit): void {
    this.push(
      node +
        '.setGap(' +
        this.tr(gutter) +
        ', ' +
        toValueJavascript(value) +
        ');',
    );
  }

  setAspectRatio(node: string, value: ValueWithUnit): void {
    this.push(node + '.setAspectRatio(' + toValueJavascript(value) + ');');
  }

  private emitGridTrackList(
    node: string,
    varName: string,
    setterName: string,
    tracks: GridTrack[],
  ): void {
    this.push(`const ${node}${varName} = [];`);
    for (const track of tracks) {
      if (track.type === 'minmax') {
        const minVal = formatGridTrackValueJS(track.min);
        const maxVal = formatGridTrackValueJS(track.max);
        this.push(
          `${node}${varName}.push({type: GridTrackType.Minmax, min: ${minVal}, max: ${maxVal}});`,
        );
      } else {
        const val = formatGridTrackValueJS(track);
        this.push(`${node}${varName}.push(${val});`);
      }
    }
    this.push(`${node}.set${setterName}(${node}${varName});`);
  }

  setGridTemplateColumns(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(
      node,
      'GridTemplateColumns',
      'GridTemplateColumns',
      tracks,
    );
  }

  setGridTemplateRows(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(
      node,
      'GridTemplateRows',
      'GridTemplateRows',
      tracks,
    );
  }

  setGridAutoColumns(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(node, 'GridAutoColumns', 'GridAutoColumns', tracks);
  }

  setGridAutoRows(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(node, 'GridAutoRows', 'GridAutoRows', tracks);
  }

  setGridColumnStart(node: string, value: number): void {
    this.push(`${node}.setGridColumnStart(${value});`);
  }

  setGridColumnStartSpan(node: string, value: number): void {
    this.push(`${node}.setGridColumnStartSpan(${value});`);
  }

  setGridColumnEnd(node: string, value: number): void {
    this.push(`${node}.setGridColumnEnd(${value});`);
  }

  setGridColumnEndSpan(node: string, value: number): void {
    this.push(`${node}.setGridColumnEndSpan(${value});`);
  }

  setGridRowStart(node: string, value: number): void {
    this.push(`${node}.setGridRowStart(${value});`);
  }

  setGridRowStartSpan(node: string, value: number): void {
    this.push(`${node}.setGridRowStartSpan(${value});`);
  }

  setGridRowEnd(node: string, value: number): void {
    this.push(`${node}.setGridRowEnd(${value});`);
  }

  setGridRowEndSpan(node: string, value: number): void {
    this.push(`${node}.setGridRowEndSpan(${value});`);
  }
}
