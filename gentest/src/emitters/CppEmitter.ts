/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */

import Emitter from './Emitter.ts';
import type {ValueWithUnit, GridTrack, GridTrackValue} from '../Types.ts';

function toValueCpp(value: string | number): string {
  const n = value.toString().replace('px', '').replace('%', '');
  if (!Number.isFinite(Number(n))) {
    return n;
  }

  return n + (Number(n) % 1 !== 0 ? 'f' : '');
}

function toFunctionNameCpp(value: ValueWithUnit): string {
  switch (value.type) {
    case 'percent':
      return 'Percent';
    case 'auto':
      return 'Auto';
    case 'max-content':
      return 'MaxContent';
    case 'fit-content':
      return 'FitContent';
    case 'stretch':
      return 'Stretch';
    default:
      return '';
  }
}

function valueWithUnitToString(value: ValueWithUnit): string {
  switch (value.type) {
    case 'points':
      return toValueCpp(value.value);
    case 'percent':
      return toValueCpp(value.value);
    case 'auto':
      return 'YGAuto';
    case 'max-content':
      return 'MaxContent';
    case 'fit-content':
      return 'FitContent';
    case 'stretch':
      return 'Stretch';
    case 'undefined':
      return 'YGUndefined';
  }
}

function formatGridTrackValue(track: GridTrackValue): string {
  switch (track.type) {
    case 'auto':
      return 'YGAuto()';
    case 'points':
      return `YGPoints(${toValueCpp(track.value)})`;
    case 'percent':
      return `YGPercent(${toValueCpp(track.value)})`;
    case 'fr':
      return `YGFr(${toValueCpp(track.value)})`;
    default:
      return 'YGAuto()';
  }
}

export class CppEmitter extends Emitter {
  constructor() {
    super('  ');
  }

  emitCommentHeader(fixtureName: string): void {
    this.push([
      '/*',
      ' * Copyright (c) Meta Platforms, Inc. and affiliates.',
      ' *',
      ' * This source code is licensed under the MIT license found in the',
      ' * LICENSE file in the root directory of this source tree.',
      ' *',
      ' * clang-format off',
      ' * MAGIC_PLACEHOLDER',
      ' * generated by gentest/src/GentestDriver.ts from gentest/fixtures/' +
        fixtureName +
        '.html',
      ' */',
      '',
    ]);
  }

  emitPrologue(_fixtureName: string): void {
    this.push([
      '#include <gtest/gtest.h>',
      '#include <yoga/Yoga.h>',
      '#include "../util/TestUtil.h"',
      '',
    ]);
  }

  emitTestPrologue(
    name: string,
    experiments: string[],
    disabled: boolean,
  ): void {
    this.push('TEST(YogaTest, ' + name + ') {');
    this.pushIndent();

    if (disabled) {
      this.push('GTEST_SKIP();');
      this.push('');
    }

    this.push('YGConfigRef config = YGConfigNew();');
    for (const experiment of experiments) {
      this.push(
        'YGConfigSetExperimentalFeatureEnabled(config, YGExperimentalFeature' +
          experiment +
          ', true);',
      );
    }
    this.push('');
  }

  emitTestTreePrologue(nodeName: string): void {
    this.push('YGNodeRef ' + nodeName + ' = YGNodeNewWithConfig(config);');
  }

  emitTestEpilogue(_experiments: string[]): void {
    this.push(['', 'YGNodeFreeRecursive(root);']);
    this.push('');
    this.push('YGConfigFree(config);');
    this.popIndent();
    this.push(['}', '']);
  }

  emitEpilogue(): void {
    // no-op for C++
  }

  assertEQ(v0: number, v1: string): void {
    this.push('ASSERT_FLOAT_EQ(' + toValueCpp(v0) + ', ' + v1 + ');');
  }

  layoutGetLeft(node: string): string {
    return 'YGNodeLayoutGetLeft(' + node + ')';
  }

  layoutGetTop(node: string): string {
    return 'YGNodeLayoutGetTop(' + node + ')';
  }

  layoutGetWidth(node: string): string {
    return 'YGNodeLayoutGetWidth(' + node + ')';
  }

  layoutGetHeight(node: string): string {
    return 'YGNodeLayoutGetHeight(' + node + ')';
  }

  insertChild(parent: string, child: string, index: number): void {
    this.push(
      'YGNodeInsertChild(' + parent + ', ' + child + ', ' + index + ');',
    );
  }

  calculateLayout(
    node: string,
    direction: string,
    _experiments: string[],
  ): void {
    this.push(
      'YGNodeCalculateLayout(' +
        node +
        ', YGUndefined, YGUndefined, ' +
        direction +
        ');',
    );
  }

  setMeasureFunc(node: string, text: string, _flexDirection: string): void {
    this.push(`YGNodeSetContext(${node}, (void*)"${text}");`);
    this.push(
      `YGNodeSetMeasureFunc(${node}, &facebook::yoga::test::IntrinsicSizeMeasure);`,
    );
  }

  setDirection(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetDirection(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setFlexDirection(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetFlexDirection(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setJustifyContent(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetJustifyContent(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setJustifyItems(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetJustifyItems(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setJustifySelf(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetJustifySelf(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setAlignContent(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetAlignContent(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setAlignItems(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetAlignItems(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setAlignSelf(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetAlignSelf(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setPositionType(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetPositionType(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setFlexWrap(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetFlexWrap(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setOverflow(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetOverflow(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setDisplay(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetDisplay(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setBoxSizing(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetBoxSizing(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setFlexGrow(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetFlexGrow(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setFlexShrink(node: string, value: string): void {
    this.push(
      'YGNodeStyleSetFlexShrink(' + node + ', ' + toValueCpp(value) + ');',
    );
  }

  setFlexBasis(node: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (
      suffix === 'Auto' ||
      suffix === 'MaxContent' ||
      suffix === 'FitContent' ||
      suffix === 'Stretch'
    ) {
      this.push('YGNodeStyleSetFlexBasis' + suffix + '(' + node + ');');
    } else {
      this.push(
        'YGNodeStyleSetFlexBasis' + suffix + '(' + node + ', ' + v + ');',
      );
    }
  }

  setWidth(node: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (
      suffix === 'Auto' ||
      suffix === 'MaxContent' ||
      suffix === 'FitContent' ||
      suffix === 'Stretch'
    ) {
      this.push('YGNodeStyleSetWidth' + suffix + '(' + node + ');');
    } else {
      this.push('YGNodeStyleSetWidth' + suffix + '(' + node + ', ' + v + ');');
    }
  }

  setHeight(node: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (
      suffix === 'Auto' ||
      suffix === 'MaxContent' ||
      suffix === 'FitContent' ||
      suffix === 'Stretch'
    ) {
      this.push('YGNodeStyleSetHeight' + suffix + '(' + node + ');');
    } else {
      this.push('YGNodeStyleSetHeight' + suffix + '(' + node + ', ' + v + ');');
    }
  }

  setMinWidth(node: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (
      suffix === 'Auto' ||
      suffix === 'MaxContent' ||
      suffix === 'FitContent' ||
      suffix === 'Stretch'
    ) {
      this.push('YGNodeStyleSetMinWidth' + suffix + '(' + node + ');');
    } else {
      this.push(
        'YGNodeStyleSetMinWidth' + suffix + '(' + node + ', ' + v + ');',
      );
    }
  }

  setMinHeight(node: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (
      suffix === 'Auto' ||
      suffix === 'MaxContent' ||
      suffix === 'FitContent' ||
      suffix === 'Stretch'
    ) {
      this.push('YGNodeStyleSetMinHeight' + suffix + '(' + node + ');');
    } else {
      this.push(
        'YGNodeStyleSetMinHeight' + suffix + '(' + node + ', ' + v + ');',
      );
    }
  }

  setMaxWidth(node: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (
      suffix === 'Auto' ||
      suffix === 'MaxContent' ||
      suffix === 'FitContent' ||
      suffix === 'Stretch'
    ) {
      this.push('YGNodeStyleSetMaxWidth' + suffix + '(' + node + ');');
    } else {
      this.push(
        'YGNodeStyleSetMaxWidth' + suffix + '(' + node + ', ' + v + ');',
      );
    }
  }

  setMaxHeight(node: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (
      suffix === 'Auto' ||
      suffix === 'MaxContent' ||
      suffix === 'FitContent' ||
      suffix === 'Stretch'
    ) {
      this.push('YGNodeStyleSetMaxHeight' + suffix + '(' + node + ');');
    } else {
      this.push(
        'YGNodeStyleSetMaxHeight' + suffix + '(' + node + ', ' + v + ');',
      );
    }
  }

  setMargin(node: string, edge: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (suffix === 'Auto') {
      this.push('YGNodeStyleSetMarginAuto(' + node + ', ' + edge + ');');
    } else {
      this.push(
        'YGNodeStyleSetMargin' +
          suffix +
          '(' +
          node +
          ', ' +
          edge +
          ', ' +
          v +
          ');',
      );
    }
  }

  setPadding(node: string, edge: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    this.push(
      'YGNodeStyleSetPadding' +
        suffix +
        '(' +
        node +
        ', ' +
        edge +
        ', ' +
        v +
        ');',
    );
  }

  setPosition(node: string, edge: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    if (suffix === 'Auto') {
      this.push('YGNodeStyleSetPositionAuto(' + node + ', ' + edge + ');');
    } else {
      this.push(
        'YGNodeStyleSetPosition' +
          suffix +
          '(' +
          node +
          ', ' +
          edge +
          ', ' +
          v +
          ');',
      );
    }
  }

  setBorder(node: string, edge: string, value: ValueWithUnit): void {
    const v = valueWithUnitToString(value);
    this.push('YGNodeStyleSetBorder(' + node + ', ' + edge + ', ' + v + ');');
  }

  setGap(node: string, gutter: string, value: ValueWithUnit): void {
    const suffix = toFunctionNameCpp(value);
    const v = valueWithUnitToString(value);
    this.push(
      'YGNodeStyleSetGap' +
        suffix +
        '(' +
        node +
        ', ' +
        gutter +
        ', ' +
        v +
        ');',
    );
  }

  setAspectRatio(node: string, value: ValueWithUnit): void {
    const v = valueWithUnitToString(value);
    this.push('YGNodeStyleSetAspectRatio(' + node + ', ' + v + ');');
  }

  private emitGridTrackList(
    node: string,
    varName: string,
    setterName: string,
    tracks: GridTrack[],
  ): void {
    this.push(`auto ${node}_${varName} = YGGridTrackListCreate();`);
    for (const track of tracks) {
      if (track.type === 'minmax') {
        const minVal = formatGridTrackValue(track.min);
        const maxVal = formatGridTrackValue(track.max);
        this.push(
          `YGGridTrackListAddTrack(${node}_${varName}, YGMinMax(${minVal}, ${maxVal}));`,
        );
      } else {
        const val = formatGridTrackValue(track);
        this.push(`YGGridTrackListAddTrack(${node}_${varName}, ${val});`);
      }
    }
    this.push(`YGNodeStyleSet${setterName}(${node}, ${node}_${varName});`);
    this.push(`YGGridTrackListFree(${node}_${varName});`);
  }

  setGridTemplateColumns(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(
      node,
      'gridTemplateColumns',
      'GridTemplateColumns',
      tracks,
    );
  }

  setGridTemplateRows(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(
      node,
      'gridTemplateRows',
      'GridTemplateRows',
      tracks,
    );
  }

  setGridAutoColumns(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(node, 'gridAutoColumns', 'GridAutoColumns', tracks);
  }

  setGridAutoRows(node: string, tracks: GridTrack[]): void {
    this.emitGridTrackList(node, 'gridAutoRows', 'GridAutoRows', tracks);
  }

  setGridColumnStart(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridColumnStart(${node}, ${value});`);
  }

  setGridColumnStartSpan(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridColumnStartSpan(${node}, ${value});`);
  }

  setGridColumnEnd(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridColumnEnd(${node}, ${value});`);
  }

  setGridColumnEndSpan(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridColumnEndSpan(${node}, ${value});`);
  }

  setGridRowStart(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridRowStart(${node}, ${value});`);
  }

  setGridRowStartSpan(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridRowStartSpan(${node}, ${value});`);
  }

  setGridRowEnd(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridRowEnd(${node}, ${value});`);
  }

  setGridRowEndSpan(node: string, value: number): void {
    this.push(`YGNodeStyleSetGridRowEndSpan(${node}, ${value});`);
  }
}
